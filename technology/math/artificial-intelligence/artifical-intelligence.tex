% 定义文档类型：中文文章
\documentclass{ctexart}

% 导入宏包
\usepackage{tikz}
\usepackage{listings}
\usepackage{color}
\usepackage{geometry}

% 一些包有多个模块，加载指定模块
\usetikzlibrary{positioning}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

% 自定义 Python 语法高亮样式
\lstset{
	language=Python,
	% 上下边距
	aboveskip=3mm,
	belowskip=3mm,
	% 字符串中的空格可见
	showstringspaces=false,
	% 设置列的对其方式
	columns=flexible,
	% 基础输出格式
	basicstyle={\small\ttfamily},
	% 显示行号
	numbers=none,
	numberstyle=\tiny\color{gray},
	keywordstyle=\color{blue},
	commentstyle=\color{dkgreen},
	stringstyle=\color{mauve},
	sensitive=true,
	breaklines=true,
	breakatwhitespace=true,
	tabsize=4,
	frame=single
}
% 设置纸张为 A4，版心占页面长度的比例为80%
\geometry{a4paper, scale=0.8}

% 文档标题
\title{人工智能-基础篇}
\author{aszswaz}
\date{2022-03-17}

\begin{document}
\maketitle

\section{Rosenblatt 感知器}
Rosenblatt 感知器是第一个从算法上完整描述的神经网络。假设 $w$ 为斜率、$t$ 为标准答案、$e$ 为误差、$a$ 为实数，感知器的流程图如下：\\
% 绘制函数流程图
\begin{center}
	\begin{tikzpicture}[
			% 有圆角的长方形
			squarednode/.style={rectangle, draw=black, minimum size=5mm, rounded corners},
			% 看不见的像素点，用来连接线，达到折线的效果
			point/.style={coordinate, on grid}
		]
		%Nodes
		\node[squarednode]      (maintopic)                                                 {输入$x$};
		\node[squarednode]      (gety)          [below of=maintopic]                        {$y = w \cdot x$};
		\node[squarednode]      (error)         [below of=gety]                             {$t - y = e$};
		\node[squarednode]      (neww)          [below of=error]                            {$n = w + a \cdot e \cdot x$};
		\node[squarednode]      (assgin)        [below of=neww]                             {$w = n$};
		\node[point]            (point1)        [left of=assgin, node distance=2cm]         {point1};

		%Lines
		\draw[->] (maintopic)       --            (gety);
		\draw[->] (gety)            --            (error);
		\draw[->] (error)           --            (neww);
		\draw[->] (neww)            --            (assgin);
		% 绘画一个点，并链接两条线，形成一个折线
		\draw[-]  (assgin)          --            (point1);
		\draw[->] (point1)          |-            (gety);
	\end{tikzpicture}
\end{center}

Python 代码如下：
\begin{lstlisting}
#!./venv/bin/python

import numpy as np
from matplotlib import pyplot as plt

"""
Rosenblatt 感知器，实验的步骤如下：
准备：设定斜率为 1.2，随机生成一组豆豆的坐标。
实验目标：在不知道斜率的情况下，让机器自行运算出豆豆在坐标系的排列斜率

author: aszswaz
wikipedia: https://zh.wikipedia.org/wiki/%E6%84%9F%E7%9F%A5%E5%99%A8
"""


def get_beans(counts):
    """
    按照 1.2 的斜率，生成有毒的痘痘在坐标系的坐标
    """
    xs = np.random.rand(counts)
    xs = np.sort(xs)
    ys = [1.2 * x + np.random.rand() / 10 for x in xs]
    return xs, ys


# 有毒的痘痘
xs, ys = get_beans(100)

# 设置坐标轴窗口
plt.title("SIze-Toxicity Function", fontsize=12)
plt.xlabel("Bean SIze")
plt.ylabel("Toxicity")

# 绘制痘痘
plt.scatter(xs, ys)
# 坐标系中直线的斜率
w = 0.5
# 学习率
alpha = 0.05

y_pre = None
for m in range(100):
    for i in range(100):
        x = xs[i]
        y = ys[i]
        # 根据当前的斜率，计算直线的下一个 y 坐标
        y_pre = w * x
        # 计算下一个 y 坐标与豆豆的实际 y 坐标差
        e = y - y_pre
        # 如果斜率过大，那么 e 就是负数，也就是减小误差，如果斜率过小，那么 e 就是正数，也就是增加斜率。学习率 alpha 是为了限制斜率 w 每次增加或减少的数值不要过大，乘以 x 是因为负坐标轴与正坐标轴的斜率调整是正好相反的
        w = w + alpha * e * x

y_pre = w * xs

plt.plot(xs, y_pre)
plt.show()
\end{lstlisting}

\end{document}
