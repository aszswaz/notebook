# 简介

本文用于记录 OS 中的一些笔记

# OS 基本概念

## 内核模式和用户模式

内核模式和用户模式是相对于 CPU 而言的。 内核模式是指运行在特权级别 0 的 CPU，而用户模式是指运行在特权级别 3 的 CPU。

用户进程进入内核态：表示当前进程由于来自内核或外部的中断而暂时终止执行，并在中断程序保存其上下文后开始执行一段内核代码。

应用程序可以直接跨标准库执行系统调用。 对于Linux系统，直接嵌入汇编代码`int 0x80`即可直接执行系统调用。 当然，系统调用子函数号要提前准备好，子函数号使用寄存器`eax`存储。

## [x86 内存分段](https://zh.wikipedia.org/zh-cn/X86%E8%A8%98%E6%86%B6%E9%AB%94%E5%8D%80%E6%AE%B5)

x86 架构的 CPU，使用段基地址 + 段内偏移的方式访问内存，并不是直接使用物理地址访问内存。段基地址存储于各个段寄存器中：

* 代码段寄存器 CS 与寄存器IP相配合获得当前线程代码执行到的内存位置
* 数据段寄存器 DS 与各通用寄存器配合访问内存中的数据
* 栈段寄存器 SS 与寄存器 (E)SP、(E)BP 配合访问线程的调用栈（call stack）
* 扩展段寄存器 ES 用于特定字符串指令（如 MOVS 或 CMPS）。
* 80386引入了2个额外的段寄存器 FS 与 GS，并无特定的硬件用途。

由于因特尔 8086 CPU 的段寄存器是16位的，只能访问 64 KB 内存，而内存地址总线是20位的，可以访问 1 MB 内存，因此，内存物理地址的计算公式为：物理地址 = 段基址 \* 16 + 段内偏移地址。

## [实模式和保护模式](https://zh.wikipedia.org/zh-cn/X86%E8%A8%98%E6%86%B6%E9%AB%94%E5%8D%80%E6%AE%B5#80286%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F)

> Intel 80286 处理器仍然使用 16 位段寄存器与 16 位的段内偏移地址，但保护模式下支持访问 224（16M）字节的内存。16 位段寄存器内不再是段地址，**16 位段寄存器的高 13 位被称作段选择符（segment selector），其值是到段描述符表的索引值。**段描述符中包含了 24 位的段开始的基地址，20 位的段长度。段开始地址与段内偏移地址相加即为内存物理地址。段的长度上限为 220 = 1M 字节。
>
> Intel 80386 处理器继续使用 286 的分段保护模式，但段描述符中包含了 32 位的段开始的基地址。段内偏移地址也是 32 位。在分段转址与物理地址之间又增加了一层**分页（paging）转址**。分段寻址是不能关闭的。分页可以使能或关闭（enabled or disabled），如果关闭就与 286 保护模式一样。**如果使用分页机制，则由段开始的基地址与段内偏移地址相加得到的是线性地址（虚地址），线性地址还需要分页转址才得到内存物理地址。**

### 实模式

实模式下，CPU 仅能访问 1 MB 内存，其内存布局如下：

| 起始    | 结束    | 大小     | 用途                                                   |
| ------- | ------- | -------- | ------------------------------------------------------ |
| 0x00000 | 0x003FF | 1 KB     | 中断向量表                                             |
| 0x00400 | 0x004FF | 256 B    | BIOS Data Area（BIOS 数据区域）                        |
| 0x00500 | 0x07BFF | 30464 B  | 通用区域                                               |
| 0x07C00 | 0x07DFF | 512 B    | MBR 被 BIOS 加载到此处                                 |
| 0x07E00 | 0x9FBFF | 622080 B | 通用区域                                               |
| 0x9FC00 | 0x9FFFF | 1 KB     | 拓展 BIOS 数据区域                                     |
| 0xA0000 | 0xAFFFF | 64 KB    | 用于彩色显示器                                         |
| 0xB0000 | 0xB7FFF | 32 KB    | 用于黑白显示器                                         |
| 0xB8000 | 0xBFFFF | 32 KB    | 用于文本模式显示器                                     |
| 0xF0000 | 0xFFFEF | 64 KB    | BIOS                                                   |
| 0xFFFF0 | 0xFFFFF | 16 B     | BIOS 入口地址，此处是固定的内容，为 jmp 0xF000: 0xE05B |

实模式有以下缺陷：

1. 操作系统和用户程序属于同一个特权级，用户程序可以访问任意内存，甚至是需盖 OS 内核所在的内存。
2. 访问超过 64 KB 的内存区域时要切换段基址。
3. 一次只能运行一个程序
4. 只能访问 1 MB 内存

### 保护模式

为了解决实模式的缺陷，Intel 和 AMD 开发出了保护模式。在保护模式中，程序不能直接使用物理地址访问内存，只能通过虚拟地址访问内存。虚拟地址需要被转换为物理地址之后再去访问内存。地址转换是由处理器和 OS 共同协作完成的，处理器在硬件上提供地址转换部件，OS 提供转换过程中所需要的页表。

在保护模式下，段寄存器存储的不再是段基址，而是 [GDT](#全局描述符表) 的选择子，类似于数组的索引，用于从 GDT 获取内存的段描述信息。

基址寄存器不再只是 bx、bp，而是所有 32 位通用寄存器，变址寄存器也不再只是 si、di，而是除 esp 之外的所有 32 位通用寄存器。

#### [全局描述符表](https://en.wikipedia.org/wiki/Global_Descriptor_Table)

全局描述符表（Global Descriptor Table，缩写为 GDT），是一个从 Intel 8086 处理器开始用于界定不同内存区域的特征数据结构。全局描述表位于内存中。全局描述表的条目描述及规定了不同内存分区的各种特征，包括基地址、大小和访问等特权如可执行和可写等。在 Intel 术语中，这些内存区域被称为段。

GDT 中，segment descriptor 的结构：

![](./assets/SegmentDescriptor.svg)

**Base Address**，段的起始内存地址。 它的长度为 32 位，由低位 16 到 31 位，高位 0 到 7 位，然后是 24 到 31 位组成。

**Segment Limit**，它的长度为 20 位，由低位 0 到 15 位和高位 16 到 19 位组成。它定义了最后可访问数据的地址。 长度比此处存储的值大一。 这应该如何解释取决于段描述符的粒度位。

**G（Granularity）**，如果为 0，则以字节为单位，最大为 $2^{20}$ byte。 如果为 1，则以内存页为单位，每个内存页大小位 4096 byte，最大为 $2^{32}$ byte。

**D（Default operand size）**，如果为 0，表示这是一个 16 bit 代码段，如果为 1，表示这是一个 32 bit 段。

**B（Big）**，如果为 1，数据段的最大偏移量将增加到 32 位 0xffffffff。 否则，最大偏移量是 16 位 0x0000ffff。 本质上与“D”的含义相同。

**L（Long）**，如果为 1，表示这是一个 64 位段（ “D/B” 必须为零），并且该段中的代码使用 64 位指令编码。 L 和 D/B 不能同时为 1。

**P（Present）**，如果清除，则对该段的任何引用都会生成“段不存在”异常。

**DPL（Descriptor privilege level）**，访问此描述符所需的特权级别。

**Type**，如果设置，这是一个代码段描述符。 如果清除，这是一个数据/堆栈段描述符，其中“D”替换为“B”，“C”替换为“E”，“R”替换为“W”。 这实际上是 2 位类型字段的一种特殊情况，其中前面的第 12 位清除为“0”是指更多的内部系统描述符，用于 LDT、LSS 和门。

**C（Conforming）**，此段中的代码可以从较低特权级别调用。

**E（Expand-Down）**，如果清除，该段将从基地址扩展到基地址+限制。 如果设置，它会从最大偏移量扩展到限制，通常用于堆栈的行为。

**R（Readable）**，如果清除，则可以执行该段但不能从中读取。

**W（Writable）**，如果清除，数据段可以被读取，但不能被写入。

**A（Accessed）**，当段被访问时，该位由硬件设置为 1，并由软件清零。

#### 段描述符缓冲寄存器

段描述符缓冲寄存器的作用是缓存段描述符，避免 CPU 频繁的从全局描述符表读取段描述符。段描述符寄存器结构如图：

80286 处理器：

| 47 ~ 32 | 31   | 30 ~ 29 | 28   | 27 ~ 24 | 23 ~ 0 |
| ------- | ---- | ------- | ---- | ------- | ------ |
| Limit   | P    | DPL     | S    | Type    | base   |

80386/80486 处理器：

| 95 ~ 64 | 63 ~ 32 | 31 ~ 24 | 23   | 22 ~ 21 | 20   | 19 ~ 16 | 15   | 14   | 13 ~ 0 |
| ------- | ------- | ------- | ---- | ------- | ---- | ------- | ---- | ---- | ------ |
| limit   | base    | 0       | P    | DPL     | S    | Type    | 0    | D/B  | 0      |

奔腾处理器：

| 95 ~ 79 | 78   | 77 ~ 72 | 71   | 70 ~ 69 | 68   | 67 ~ 64 | 63 ~ 32 | 31 ~ 0 |
| ------- | ---- | ------- | ---- | ------- | ---- | ------- | ------- | ------ |
| 0       | D/B  | 0       | P    | DPL     | S    | type    | base    | limit  |

## 计算机启动时的加载顺序

在主板接通电源后，CPU 会首先从主板的固件中，加载 BIOS 程序到地址 0xF0000～0xFFFFF 处，入口地址是 0xFFFF0。BIOS 会自动完成所有设备的开机自检，以及 USB 等外设的初始化工作，随后 BIOS 会读取各个存储器设备中，第一个扇区的 512 个字节，如果这 512 个字节的最后两个字节是 0x55 和 0xAA，BIOS 就会认为前 510 个字节为 [MBR 主引导记录](mbr.md)，会将其加载到 0x7C00 处，并开始执行 MBR 程序，由 MBR 负责启动操作系统的主引导器。

# IO 接口

IO 接口是连接 CPU 与外部设备的逻辑控制部件，分为硬件和软件两部分，硬件部分的功能是协调 CPU 和外设之间的种种不匹配，例如双方的速度不匹配，那 IO 接口就实现数据缓冲以减少等待时间，数据格式不匹配，IO 接口就在这两种格式间互相转换。IO 接口内部实际上也是由软件（驱动程序）来控制运作的，这就是所谓的逻辑部分。

对 IO 接口的操作有两种方式，一种是通过 CPU 的地址总线进行操作，比如显存被映射到地址 0xB8000 ～ 0xA0000，想要往屏幕上输出 ASCII 字符，只需要通过 mov 指令向该地址写入数据即可，另一种方式是通过 IO 端口进行操作，IO 端口实际上是 IO 寄存器，不同的接口，IO 寄存器是不一样的。

IO 接口主要功能如下：

* 设置数据缓冲，解决 CPU 与外设之间的速度不匹配
* 设置信号电平转换电路
    CPU 和外设的信号电平不同，如 CPU 所用的信号是 TTL 电平，而外设大多数机电设备，因此不能使用 TTL 电平驱动，可以在接口电路中设置电平转换电路来解决
* 设置数据格式转换
    外设是多种多样的，输出的信息可能是数字信号，模拟信号等，而 CPU 只能处理数字信号。数字信号需要经过数/模转换（D/A）成模拟量才能被送到外设以驱动硬件，模拟量也同样需要经过数/模转换（A/D）转换成数字量才能被 CPU 处理。即使双方都使用数字信号，这也会牵扯到字长问题，如 CPU 使用的是 8 位、16 位、32 位并行数据，而外设使用并行或串行数据都有可能。
* 设置时序控制电路来同步 CPU 和外部设备
    硬件的工作也按照某种时序，它们都用自己的时序系统，就像 CPU 工作在自己的晶振时序上一样，双方时序不同，接口电路就要协调这两种不同的时间记法。
* 提供地址译码
    CPU 同多个硬件打交道，每个硬件要反馈的信息很多，所以一个 IO 接口必须包含多个端口，即 IO 接口上的寄存器，来存储这些内容。但同一时刻，只能有一个端口和 CPU 进行数据交换，这就需要 IO 接口提供地址译码电路，使 CPU 可以选中某个端口，使其可以访问数据总线。

## IO 接口种类

### [串行端口](https://en.wikipedia.org/wiki/Serial_port)

串行端口是一次只能传输一位的端口。 在 20 世纪末，它的缺点是传输速度慢，但从 21 世纪初开始，它通过增加数据传输频率来提高数据传输速度。

### [并行端口](https://en.wikipedia.org/wiki/Parallel_port)

并行端口是一次可以传输多个位的端口。 20世纪末，它的传输速度比串口还快，得到了广泛的应用。 但它有一个缺陷，它必须同时发送多位数据，多位数据也必须同时到达，如果一位数据丢失，则必须重新发送多位数据。

### [USB](https://en.wikipedia.org/wiki/USB)

串行和并行端口已在很大程度上被 USB 端口所取代。 USB 本质上是对串行端口的改进，其接口内部有多个串行端口，称为端点。

USB 也可以并行传输，但与并行端口不同的是，如果在传输过程中数据丢失，则不需要重新发送所有数据。

例如，如果同时发送8位数据，如果一位发送失败，则并口需要重新发送8位数据，而USB只需要重新发送丢失的位数据。

每个 USB 端口都有一个对应的编号。 默认端口 0 作为控制端口，用于传输控制命令。 USB 主机可以通过命令指定使用哪些端口进行传输。

## [输入输出控制芯片](https://zh.wikipedia.org/zh-cn/%E5%8D%97%E6%A1%A5)

输入输出控制芯片（I/O control hub，ICH），也称南桥芯片。同一时刻，CPU 只能和一个 IO 接口通信，当很多的 IO 接口同时想和 CPU 对话时，南桥负责仲裁 IO 接口的竞争。南桥包含大多数周边设备接口、多媒体控制器和通信接口功能。例如 PCI / 低速 PCIe（如 PCIe x1）控制器、ATA/SATA 控制器、USB 控制器、网络控制器、音效控制器。

[北桥](https://zh.wikipedia.org/zh-cn/%E5%8C%97%E6%A1%A5)和南桥总是成对出现，北桥用来处理高速信号，例如中央处理器、存储器、集成式 GPU、高速总线（如 [PCI Express](https://zh.wikipedia.org/zh-cn/PCI_Express) 接口或 [AGP](https://zh.wikipedia.org/zh-cn/AGP) 接口）控制器，还有与南桥之间的通信。

## [显卡](https://zh.wikipedia.org/zh-cn/%E6%98%BE%E7%A4%BA%E5%8D%A1)

显示适配器，简称显卡。CPU 无论是要操作 [LCD 显示器](https://zh.wikipedia.org/zh-cn/%E6%B6%B2%E6%99%B6%E6%98%BE%E7%A4%BA%E5%99%A8)，还是操作 [OLED 显示器](https://zh.wikipedia.org/zh-cn/%E6%9C%89%E6%A9%9F%E7%99%BC%E5%85%89%E4%BA%8C%E6%A5%B5%E9%AB%94)，都需要通过显卡来完成。CPU 需要通过 mov 指令将要显示的数据发写入显存。显卡有三种工作模式：文本模式、黑白图形模式和彩色图形模式。在黑白图形模式下，显存的 1 bit 对应显示器的 1 个像素，在文本和彩色图形模式下，显存的 24 bit 对应 1 个像素，也就是 24 位真彩色。

### 显存地址分布

| 起始    | 结束    | 大小  | 用途                   |
| ------- | ------- | ----- | ---------------------- |
| 0xC0000 | 0xC7FFF | 32 KB | 显示适配器 BIOS        |
| 0xB8000 | 0xBFFFF | 32 KB | 用于文本模式显示适配器 |
| 0xB0000 | 0xB7FFF | 32 KB | 用于黑白显示器         |
| 0xA0000 | 0xAFFFF | 64 KB | 用于彩色显示器         |

### 文本模式

显卡的文本模式也分为多种模式，用“列数 \* 行数”来表示，如 $80 \times 25$、$80 \times 43$ 等，默认是 $80 \times 25$。在文本模式下，也可以打印彩色的字符，每个字节都用 2 个字节来表示，一个字节是 ASCII 码本身，另一个字节表示颜色。

文本模式的显存大小是 32 KB，一屏可以显示 $80 \times 25$ 个字符，每屏字符占用 $25 \times 80 \times 2 = 4000$ B，因此，文本模式可以有  $32 \times 1024 \div 4000 = 8.192 \approx 8$ 屏，这也是 Linux 8 个 tty 的切换原理。

每个字符的低字节是字符的 ASCII 码，高字节是字符的属性信息，高 4 位是字符背景色，低 4 位是字符的前景色。颜色用 RGB 三种基色混合，第 4 位用来控制亮度，为 1 是高亮，为 0 是正常亮度。第 7 位用来控制字符是否闪烁。

显卡的文本模式不能处理换行符，要想在第 N 行输出字符，必须向该行的内存地址写入字符才行。行的地址计算公式为 $2 \times (y \times 80 + x)$，y 表示第 N 行，x 表示第 N 列，y 和 x 都是从零开始计数。例如，第二行的地址为：$2 \times (1 \times 80 + 0) = 160$。

## 硬盘

### CHS 和 LBA

硬盘中的扇区在物理上是用“柱面 - 磁头 - 扇区”来定位的，简称为 CHS，CHS 的扇区编号是从 1 开始的。

另外一种定位称为 LBA（Logical Block Address）。LBA 的扇区编号从 0 开始，寻址时，不需要计算柱面和磁头。LBA 分为 LBA28 和 LBA48，LBA28 表示 28 位的 LBA 地址，最大支持 128 GB，LBA48 最大支持 128 PB。

### IO 端口

硬盘控制器主要 IO 端口（寄存器）：

| IO 端口                 |                | 端口名称         |                |
| ----------------------- | -------------- | ---------------- | -------------- |
| Primary 通道            | Secondary 通道 | 读操作时         | 写操作时       |
| Command Block registers |                |                  |                |
| 0x1F0                   | 0x170          | Data             | Data           |
| 0x1F1                   | 0x171          | Error            | Features       |
| 0x1F2                   | 0x172          | Sector count     | Sector count   |
| 0x1F3                   | 0x173          | LBA low          | LBA low        |
| 0x1F4                   | 0x174          | LBA mid          | LBA mid        |
| 0x1F5                   | 0x175          | LBA high         | LBA high       |
| 0x1F6                   | 0x176          | Device           | Device         |
| 0x1F7                   | 0x177          | Status           | Command        |
| Control Block registers |                |                  |                |
| 0x3F6                   | 0x376          | Alternate status | Device Control |

端口可以被分为两组：Control Block registers 和 Command Block registers，Command Block registers 用于向硬盘驱动器写入命令或者从硬盘控制器获得硬盘的状态，Control Block registers 用于控制硬盘工作状态。

端口是按通道给出的，不是直接和某块硬盘关联的，要想操作某通道上的某块硬盘，需要通过 device 寄存器指定。一个通道上就只能有主从两块硬盘，因此只需要 1 位就可以指定，0 表示主盘。1 为从盘。

各个端口的详细描述：

Data：在读写硬盘时，用于存储数据，大小是 16 位

Error、Features：在读取数据时，作为存储异常信息的寄存器，读取失败后，会记录失败的信息。在写入数据时，用于存储指令参数

  Sector count：指定待读取或写入的扇区数，硬盘每完成一个扇区，就会将此寄存器的值减 1,所以如果中间失败了，此寄存器中的值便是尚未完成的扇区。这是 8 位寄存器，最大值位 255，若指定为 0，则表示要写入 256 个扇区。

LBA low、LBA mid、LBA high：LBA low 存储 LBA 的第 0～7 位，LBA mid 存储第 8～15 位，LBA high 存储第16～23位

device：此寄存器的低 4 位用于存储 LBA 地址的第 24～27 位。第 5 位用来指定通道上的主盘或从盘，0 代表主盘，1 代表从盘。第 7 位用来设置是否启用 LBA 寻址方式，1 代表启用 LBA，0 代码使用 CHS。第 6位和第 8 位固定为 1，用途未知。

Status、Command：在读硬盘时，此寄存器用于给出硬盘的状态信息。第 0 位是 ERR 位，如果此位为 1，表示指令出错，具体原因保存在 error 寄存器，第 3 位是 data request 位，此位为 1，表示硬盘已经把数据准备好了，主机现在可以把数据读出来，第 6 位是 DRDY，表示硬盘准备就绪，第 7 位是 BSY 位，表示硬盘是否繁忙，如果为 1 表示硬盘正忙，此寄存器其他位都无效。
在写硬盘时，此寄存器用于存储指令。

device 寄存器示意图：

![device 寄存器示意图](./assets/io-device.jpg)

status 寄存器示意图：

![status 寄存器示意图](./assets/io-status.jpg)

### 数据传送方式

1. 查询传送方式
    也称为程序 IO（PIO，Programming Input/Output Model），CPU 先检查设备状态，如果状态为“准备好了可以发送”，CPU 再去获取数据
2. 中断传送方式
    也称中断启动 IO，当数据源设备准备好数据后，通过发送中断通知 CPU 获取数据
3. 直接存储器存取方式
    不让 CPU 参与传输，由 DMA 控制器完成数据传输，CPU 直接从内存读取数据就行
4. IO 处理机
    IO 处理机在 DMA 基础上，自动完成数据的交换、组合、校验等，让 CPU 完全不需要参与此类工作
